#pragma warning(disable:4996)

#include<cstdio>
#define N 6 //패턴 갯수
#define H 8 //데이터 높이
#define W 6 //데이터 너비

////////////////// 트레이닝 셋 //////////////////////
short pattern[N][H * W] = { // ㄱ, ㄴ, ㄷ, ㄹ, ㅁ, ㅂ
	{
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		0,0,0,0,1,1,
		0,0,0,0,1,1,
		0,0,0,0,1,1,
		0,0,0,1,1,1,
		1,1,1,1,1,0,
		1,1,1,0,0,0
	},
	{
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1
	},
	{
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1
	},
	{
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		0,0,0,0,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1
	},
	{
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,0,0,1,1,
		1,1,0,0,1,1,
		1,1,0,0,1,1,
		1,1,0,0,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1
	},
	{
		1,1,0,0,1,1,
		1,1,0,0,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,0,0,1,1,
		1,1,0,0,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1
	}
};

//////////////////////////////////////////// 홉필드 알고리즘 //////////////////////////////////////////////////

int T, i, j;
int w[H * W][H * W], b[H * W]; // w : 가중치, b : 입력

bool Predict(int); // Predict : 예측
void Fit(), Pattern(), Input(); // Fit : 모델학습, Pattern : 패턴출력, Input : 입력

int main() {
	Pattern();
	Fit();
	Input();
	return 0;
}

void Pattern() {
	printf("--------------------------------------------패턴--------------------------------------------\n");
	for (i = 0; i < H; i++) {
		for (T = 0; T < N; T++) {
			for (j = W * i; j < W * i + W; j++)
				printf("%s", (pattern[T][j] ? "■" : "□"));
			printf("\t");
		}
		puts("");
	}
	printf("--------------------------------------------------------------------------------------------\n");
}

void Fit() {
	for (T = 0; T < N; T++) {
		// 1. 학습 패턴에 양극화 연산을 적용
		int x[H * W];
		for (i = 0; i < H * W; i++)
			x[i] = 2 * pattern[T][i] - 1;
		// 2. 학습 패턴에 대한 홉필드 네트워크의 가중치 행렬을 계산 후 저장
		for (i = 0; i < H * W; i++)
			for (j = 0; j < H * W; j++)
				w[i][j] += (i == j ? 0 : x[i] * x[j]);
	}
}

void Input() {
	puts("패턴을 8*6배열 형태( 1 : 입력, 0 : 공백 )로 입력해주세요 : \n");
	for (i = 0; i < H * W; i++)
		scanf("%d", &b[i]);
	printf("\n--------------------------------------------입력--------------------------------------------");
	for (i = 0; i < H * W; i++) {
		if (i % W == 0) puts("");
		printf("%s", (b[i] ? "■" : "□"));
	}
	int cnt = 0;
	while (Predict(++cnt)); // 일치할 때 까지 반복
	printf("\n--------------------------------------------결과--------------------------------------------");
	for (i = 0; i < H * W; i++) {
		if (i % W == 0) puts("");
		printf("%s", (b[i] ? "■" : "□"));
	}
}

bool Predict(int cnt) {
	int u[H * W] = { 0 }, t[H * W] = { 0 };
	// 입력패턴에 대한 threshold(임계값) 설정
	for (i = 0; i < H * W; i++) {
		for (j = 0; j < H * W; j++)
			t[i] += w[i][j];
		t[i] = (t[i] / -2);
	}
	// 입력 패턴에 대한 가중치와 임계값 적용
	for (i = 0; i < H * W; i++) {
		u[i] = t[i];
		for (j = 0; j < H * W; j++)
			u[i] += w[i][j] * b[j];
	}
	// 활성화 함수 적용
	for (i = 0; i < H * W; i++) {
		if (u[i] != 0)
			b[i] = (u[i] > 0 ? 1 : 0);
	}
	// 학습패턴과 비교 (같으면 false, 틀리면 true);
	bool check = true;
	for (T = 0; T < N; T++) {
		for (i = 0; i < H * W; i++)
			if (b[i] != pattern[T][i]) break;
		if (i == H * W) check = false;
	}
	return check;
}